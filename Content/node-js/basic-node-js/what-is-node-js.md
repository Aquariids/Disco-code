---
title: 'Как работает node.js. Блокирущий и неблокирущий I/O'
id: 1
category: 'basic-node-js'
---
 ## Что такое node js

 `Node.js` - позволяет нам выполнять код вне браузера. Это серверная платформа для работы с `javaScript` через  <span className = 'link_nodeJs'> [движок v8](/js/under-the-hood-js/engine)</span>. Это позволяет нам писать бэкенд. Мы можем написать и фронт и бек на одном `javaScript`.

 * `Node.js` может выполнять роль веб сервера.
 * `Node.js` умеет работать с внешними библиотеками.
 * `Node.js` позволяет взаимодействовать с операционной системой и устройствами ввода/вывода через `api` написанное на c++
    <small>
    устройства ввода/вывода - это устройства с которых компьютер получает или передает информацию.
    Например компьютерная мышь и клавиатура это устройства ввода. А монитор и колонки - устройства вывода.
    Так же есть устройства ввода и вывода - это флешка например или жесткий диск.
    </small>
 * Зная немного `javaScript` можно уже начинать изучение `Node.js`.
 * Благодаря асинхронности `Node.js` распределяет ресурсы грамотнее, что позволяет ему быть очень быстрым.

## На чем построен node js

* В первую очередь это движок v8 с помощью которого <b>`javaScript` код преобразуется в машинный код.</b>

* А также `libuv` - это библиотека написанная на языке `C`, которая отвечает за асинхронный <b>неблокирующий ввод/вывод операций </b> в `Node.js`.
    `Libuv` <b>позволяет сделать `node.js` кроссплатформенным.</b>
    Именно `libuv` знает как работать на разных операционных системах.
    Мы используем например метод для работы с файловой системой, `node.js` внутри себя как раз будет использовать `libuv` и мы даже не будем задумываться на какой операционной системе находимся.

### Блокирущий ввод и вывод(Input/Outup). Многопоточность
Это синхронное выполнение. Мы выполняем команду за командой и если есть трудоёмкая операция, то поток будет заблокирован пока ее не выполнит. Для решения такой проблемы, операции выполняют в разных потоках.
Один поток работает с базой данных, другой с файловой системой, третий работает с сетью и так далее.
Все это происходит на уровне операционной системы. Так работают классические веб сервера на `java`.

<div className='container-img'> <span className="img"> ![blocking](/images/Content/node-js/blocking-I-O.png) </span></div>

У блокирующего ввода и вывода есть минусы: 
* Потребление <b>большого </b> количества ресурсов и <b>сложность</b> в управлении потоками.
* Как видим потоки некоторое время находятся в <b>состоянии простоя</b> ожидая новых данных получаемых из связанных с ним соединений.
При этом, в это время, они потребляют ресуры. 
* Чем больше у нас потоков, тем больше мы будем <b>тратить времени на переключение контекста</b>.

    <small>
    Переключение контекста (context switch) - это процесс записи и восстановления состояния процесса или потока таким образом, чтобы в дальнейшем продолжить его выполнение с прерванного места.
    </small>
* Потоки <b>занимают место</b> в оперативной памяти.


### Неблокирущий ввод и вывод
В таком режиме сервер работает с одним главным потоком. В неблокирующим режиме системные вызовы возвращают управление немедленно не дожидаясь чтения или записи данных.
Основной шаблон реализации такого режима является активный опрос ресурса в цикле до тех пор, пока не будут возвращены какие либо фактические данные - это называется цикл ожидания. Поток при всем этом не блокируется.

<small>
`busy waiting` - Занят ожиданием или проще можно назвать как цикл ожидания — метод,
при котором процесс многократно проверяет, верно ли условие, например, доступен ли ввод с клавиатуры.
</small>

<div className='container-img'> <span className="img"> ![noneBlocking](/images/Content/node-js/noneBlocking-i-o.png) </span></div>

С помощью такой техники уже можно обрабатывать разные ресурсы в одном потоке, но это все еще неэффективно.
Хорошо, что большинство современных операционных систем предоставляют встроенный механизм для более эффективной работы неблокирующего `I/O`.
Этот механизм называется синхронным демультиплексором событий. И тут мы переходим к `libuv`.

## Подробнее про libuv
Начнем с того, что `node.js` однопоточный. Но в основе `node.js` лежит `libuv`, который занимается операциями ввода и вывода и может управлять потоками, по умолчанию их 4.
```javaScript
// Пример из ролика ubliTv. ссылка есть в начале урока.
const crypto = require('crypto');

const start = Date.now(); // время начала

// используем функцию для шифровки пароля 1000000 - это кол итераций
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('1 закончил за', Date.now() - start ); // вычитаем из времени выполнения время начала скрипта.
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('2 закончил за', Date.now() - start );
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('3 закончил за', Date.now() - start );
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('4 закончил за', Date.now() - start );
});

// у нас получился такой вывод в миллисекундах
/*
1 закончил за 1128
2 закончил за 1196
3 закончил за 1247
4 закончил за 1269
*/
```
Как видим выполнение плюс минут за одно время, но если мы добавим еще одну операцию.
```javaScript
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('1 закончил за', Date.now() - start );
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('2 закончил за', Date.now() - start );
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('3 закончил за', Date.now() - start );
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('4 закончил за', Date.now() - start );
});
crypto.pbkdf2('qwerty', '5', 1000000, 64, 'sha512', () => {
    console.log('5 закончил за', Date.now() - start );
});


/*
2 закончил за 1086
1 закончил за 1095
3 закончил за 1115
4 закончил за 1139
5 закончил за 1888
*/
```
Пятый запуск отработал гораздо позже. Если добавим еще, то будет так же. Первые четыре выполнения всегда будут плюс минус равны, остальные уже будут отставать.
`Libuv` состоит из:
1. Демультиплексор событий (Event Demultiplexor)
2. Очереди событий (Event Queue)
3. Цикл событий (Event Loop) 


