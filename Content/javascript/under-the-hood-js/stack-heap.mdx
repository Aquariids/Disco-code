---
title: 'Как хранятся значения и объекты в памяти heap & stack'
id: 5
prev: '/js/under-the-hood-js/this'
category: 'under-the-hood-js'
---

<div className = 'mdHead'>

#### Теги
<div className = 'tag_js'> [Stack & heap:](#stack--heap) </div>
<div className = 'mini_tag_js'> [примитивные значения,](#примитивные-значения) </div>
<div className = 'mini_tag_js'> [ссылочные значения.](#ссылочные-значения) </div>

</div>

## Stack & heap

* <b>Heap(куча)</b> - Мы уже знакомы с кучей, и в первом уроке этого руководства говорили о том, что в куче <b>хранятся все объекты и функции</b>, и то, что здесь используется динамическое выделение памяти. Динамическое оно потому, что движок не знает, сколько ему понадобится памяти под тот или иной объект, а потому выделяет память по мере необходимости. Сюда включены и функции с их контекстом выполнения. Поэтому в в общем-то все данные хранятся в куче, в том числе и контекст выполнения функции. 

*  Примитивные значения, в свою очередь, хранятся в <b>контексте выполнения</b>. Память под них выделяется на этапе создания, перед выполнением кода, так как для примитивных значений существует фиксированный объем памяти.

### Примитивные значения

Теперь посмотрим на примере как это работает:
```javascript
let a = 1;
```

<div className='container-img'> <span className="img"> ![stack&heap_start_position](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_start_position.png) </span></div>

Первом делом javascript движок создаст идентификатор `a` - то есть переменную. Далее будет выделена память по определенному адресу(в моем случае это псевдо адрес) и после в память по этому адресу будет помещено значение.

* Если говорить о переменной в общем, то переменная хранит значение, а не адрес в памяти. Но в `javascript` в техническом плане, переменная представляет собой ссылку на место в памяти, где хранится значение.  Это свойство языка, а не характеристика переменной как таковой.

Добавим еще переменную и присвоем ей переменную `a`.
```javascript
let a = 1;
let b = a;
```

<div className='container-img'> <span className="img"> ![stack-heap/stack&heap_start_create_variable_b](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_start_create_variable_b.png) </span></div>

Теперь переменная `b` ссылается на тот же адрес, что и переменная `a`. Но что будет если мы перезапишем переменную `a`?
```javascript
let a = 1;
let b = a;
a = 2;
console.log(a); // 2
console.log(b); // 1
```

<div className='container-img'> <span className="img"> ![stack-heap/stack&heap_start_create_variable_b](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_start_assigned_a.png) </span></div>

В таком случае выделяется новый кусочек памяти, после этого переменная `a` указывает уже на новый адрес, с новым значением. В свою очередь, переменная `b` указывает на старый адрес.

* Примитивными значения в javascript иммутабельны(неизменны), они хранятся в памяти как константы и не могут быть изменены после создания. Когда мы создаем переменную и присваиваем ей значение `1`, это значение будет храниться в памяти как константа с типом `number`. При изменении выделяется новый кусочек памяти в котром содержится новое значение.

{/* При обращении к объектам javaScript-движок использует ссылки на данные объекты из лексического окружения.
При этом если одно лексическое окружение ссылается на другое, оно не будет удалено из памяти, пока ссылка на него не будет удалена. Это является основой работы замыканий(тут когда нибудь будет ссылка на урок). */}

### Ссылочные значения

Теперь посмотрим на объект.
```javascript
const anime = {
    name: 'gintama',
    seasons: 8
};
```

<div className='container-img'> <span className="img"> ![stack-heap/stack&heap_start_create_variable_b](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_obj.png) </span></div>

В таком случае у нас в стеке создается идентификатор <b>с новым адресом в памяти</b>, который хранит в себе <b>адрес на объект в куче</b>. Теперь попробуем создать еще объект и присвоим ему объект `anime`.

```javascript
const anime = {
    name: 'gintama',
    seasons: 8
};

const newAnime = anime;
newAnime.name = 'trigun';


console.log(anime.name); // trigun
console.log(newAnime.name); // trigun
```

<div className='container-img'> <span className="img"> ![stack-heap/stack&heap_start_create_variable_b](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_newObj.png) </span></div>

В таком случае, новая переменная, как и в примере со значениями, будет ссылаться на тот же адрес в стеке, который, в свою очередь, уже ссылается на адрес в куче. При этом, неважно, что мы объявили объект через `const`, мы не меняем значение внутри переменной `newAnime` - значение этой переменной это ссылка на объект в куче и эта ссылка остается нетронутой, мы меням значение, которое находится в куче.
