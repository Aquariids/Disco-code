---
title: 'Как хранятся значения и объекты в памяти heap & stack'
id: 5
prev: '/js/under-the-hood-js/this'
category: 'under-the-hood-js'
---

<div className = 'mdHead'>

#### Теги
<div className = 'tag_js'> [Что такое this](#что-такое-this) </div><br/>
<div className = 'tag_js'> [this такой разный](#this-такой-разный) </div>
<div className = 'mini_tag_js'> [this в обычной функции,]() </div>
<div className = 'mini_tag_js'> [Контекст у методов объекта,]() </div>
<div className = 'mini_tag_js'> [this в конструкторах и классах,]() </div>

</div>

## stack & heap

* <b>Heap </b> - мы уже знакомы с кучей, и в первом уроке этого руководства говорили, о том, что в куче <b>хранятся все объекты и функции</b> и то, что это динамическая часть памяти. 
Динамическая она потому, что движок не знает, сколько ему понадобится памяти под тот или иной объект, а потому выделяет память по мере необходимости. Сюда включены и функции с их контекстом выполнения.

* Примитивные значения в свою очередь хранятся в контексте выполнения. Память под них выделятся на этапе создания, перед выполнением кода. Это называется статическая облсать памяти. Так как для примитивных значений существует фиксированный объем памяти.

* <b>Stack </b> - это структура данных, которая представляет собой упорядоченный набор элементов, работающий по принципу "последним пришел - первым ушел.
Мы говорили об этом когда разбирали `call stack`. Так как при выполнении кода последние добавленные элементы всегда выполняются первыми, то контекст выполнения может быть представлен в виде стэка. Поэтому для удобства я буду называть это все просто стэк.


## Примитивные значения и ссылочные

### Примитивные значения
Теперь посмотрим на примере как это работает:
```javascript
let a = 1;
```

<div className='container-img'> <span className="img"> ![stack&heap_start_position](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_start_position.png) </span></div>

Первом делом javascript движок создаст идентификатор `a` - то есть переменную. Далее будет выделена память по определенному адресу(в моем случае это псевдо адрес) и после в память по этому адресу будет помещено значение.

* Если говорить о переменной в общем, то переменная хранит значение, а не адрес в памяти. Но в `javascript` в техническом плане, переменная представляет собой ссылку на место в памяти, где хранится значение.  Это свойство языка, а не характеристика переменной как таковой.

Добавим еще переменную и присвоем ей переменную `a`.
```javascript
let a = 1;
let b = a;
```

<div className='container-img'> <span className="img"> ![stack-heap/stack&heap_start_create_variable_b](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_start_create_variable_b.png) </span></div>

Теперь переменная `b` ссылается на тот же адрес, что и переменная `a`. Но что будет если мы перезапишем переменную `a`?
```javascript
let a = 1;
let b = a;
a = 2;
console.log(a); // 2
console.log(b); // 1
```

<div className='container-img'> <span className="img"> ![stack-heap/stack&heap_start_create_variable_b](/images/Content/Js/under-the-hood-js/stack-heap/stack&heap_start_assigned_a.png) </span></div>

В таком случае выделяется новый кусочек памяти, после этого переменная `a` указывает уже на новый адрес, с новым значением. В свою очередь, переменная `b` указывает на старый адрес.

* Примитивными значения в javascript неизменны, потому что они хранятся в памяти как константы и не могут быть изменены после создания. Когда мы создаем переменную типа `number` и присваиваем ей значение `1`, это значение будет храниться в памяти как константа с типом `number`. При изменении выделяется новый кусочек памяти в котром содержится новое значение.

{/* При обращении к объектам javaScript-движок использует ссылки на данные объекты из лексического окружения.
При этом если одно лексическое окружение ссылается на другое, оно не будет удалено из памяти, пока ссылка на него не будет удалена. Это является основой работы замыканий(тут когда нибудь будет ссылка на урок). */}


{/* 
Под объекты и функции память выделяется в `heap` и количество памяти будет менять в зависимости от того как будет меняться объект. Далее уже вунтри функции на фазе создания для переменных выделяется статическая память в этом контексте выполнения. Во время выполнения в память контекста помещаются разные ссылки на объекты из кучи.
Таким образом, стек вызовов служит для управления выполнением функций, а куча хранит их определения и данные. <br/> */}

### Ссылочные значения