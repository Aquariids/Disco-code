---
title: 'Scope & scope chain'
id: 2
category: 'under-the-hood-js'
date: '17.01.2022'
prev: '/js/under-the-hood-js/call-stack'
---


## Концепции scope и что это?

* `Scoping` - <b>область видимости</b>. Относится к доступности или видимости переменных. То есть, где мы можем получить <b>доступ</b> к переменной.

* `Lexical scoping`(Лексическая область видимости): контролируется размещением функций и блоков в коде. Означает, что дочерние функции лексически связаны с контекстом выполнения их родителей и дочернии функции будут иметь доступ к переменным функции родителя. Лексическую область иногда также называют статической областью так как область видимости определяется в момент определения функции (в отличие от динамической области видимости, при которой это происходит в момент вызова функции). То есть `scope` никак не зависит от вызова функций.

* `Scope`(Область действия): это среда или пространство в которой объявлена определенная переменная. В случае с функциями это `окружение переменных`. Существует глобальная область действия, область действия функций и облатсь действия блока.  

* `Scope of a variable`(Область действия переменной): область кода в которой можно получить доступ к определенной переменной.

Для описания всех этих понятий и концепций используется одно слово `scope`. Но у всех этих понятий, есть небольшие различия. Например когда мы говорим про `scope of a variable` мы подразумеваем доступность конкретной переменной в программе. Или когда мы говорим про `lexical scoping` мы сразу понимаем, что речь идет о доступе дочерней функции к переменным родительской. Мы еще раз вернемся к этим понятиям в практической части.

## Виды scope
Как мы уже ранее сказали, существует три вида области действия, сейчас разберем их подробнее.

### Global scope
Глобальная область действия относится к коду верхнего уровня.
* Переменные вне любой функции или блока.
* Переменные, объявленные в глобальном `scope`, доступны <b>везде</b>

```javaScript
const hello = 'hello'; // глобальная переменная
console.log(hello) // hello

function hi() {
    console.log(hello) // переменная доступна
}

hi() // hello 
```
### Function scope(local scope)
Каждая функция образует `scope` функций. Это как бы в противоположность глобальному `scope` поэтому и называется так же локальным `scope`.

* Переменные доступны только <b>внутри функции не</b> снаружи.
* Если вы попытаетесь получить доступ к любой переменной, определенной внутри функции, извне или из другой функции, вы получите ошибку.

```javaScript
function hi() {
    const hello = 'hello';
    console.log(hello);
    return hello;
}
hi();  // hello

// если попробуем снаружи, то получим ошибку
console.log(hello) // ReferenceError: hello is not defined
```
### Block scope(es6)
Раньше только функции могли создавать свой `scope`, но начиная с `es6`, `scope` имеют любые блоки кода.

* Переменные доступны только внутри <b>блока кода</b>.
* Это <b>применимо только</b> к перемнным <b>let</b> и <b>const</b>.

До `es6` существовал только глбальный `scope` и `scope` функций. Переменные `var` была как раз переменной области действия функции. То есть `var` была доступна везде, кроме функций. А в `es6` появился `block scope` и переменные `const` и `let` - они переменные области действия блока. Они доступны только в рамках блока кода(цикл, функция, просто блок {} и тд).

```javaScript
if (true) { // блок кода
    const one = 1;
    let two = 2;
    var three = 3; // var будет доступна и извне
    console.log(one); // 1
    console.log(two); // 2
    console.log(three); // 3
}

console.log(one); // ReferenceError
console.log(two); // ReferenceError
console.log(three); // 3  наша переменная var
```
* Функции так же имеют <b>scope блока</b>, но только в <b>strict mode</b>
```javaScript
{ // блок кода
    function hi() {
        console.log('hi');
    }
}

// наша функция доступна
hi(); // hi
```
Но если мы будем использовать `"use strict"`, то мы не сможем вызвать функцию, так как она станет ограничена блоками кода.
```javaScript
"use strict";

{
    function hi() {

        console.log('hi');
    }
}

hi(); // ReferenceError
```
## Scope chain
Разберем как работает цепь областей видимости(`scope chain`).
```javaScript
const name = 'Dima'; // глобальная переменная

function person(age) { // аргумент
    const love = 'anime';
    function dating() {
        const hello = 'Hello'; // локальная переменная функции 
        // Тут мы используем глобальную переменную, локальную и аргумент и переменную родителя.
        console.log(`${hello}, my name is ${name} I'm ${age} old and i love ${love}`);
        // Hello, my name is Dima I'm 26 old and i love anime
    }
    dating();

}

person(26);
```
Теперь посмотрим на каждый `scope` отдельно.

#### Global scope примера.
```
name = 'Dima';
person  = <КОД ФУНКЦИИ> - переменная с функцией
```
#### scope функции person()
```
love = 'anime';
dating = <КОД ФУНКЦИИ> - переменная с функцией
Массиво подобный объект arguments c аргументамом 26.
```
#### scope функции dating()
```
hello = 'hello'
```
Внутри функции `dating` мы обращаемся к переменным из других `scope` и мы можем их использовать.
Так как любой `scope` <b>имеет доступ</b> к перменным из <b>внешних</b> `scope`.
Это и есть концепция о которой мы уже говорили `lexical scoping`. Вся это цепь от самого дочернего вложенного `scope` и до глобального `scope` - называется `scope chain`.
Cам процесс поиска называется поиск переменных в `scope chain`. Все это <b>не работает</b> в обратном направлении. То есть никакой `scope` не имеет доступа к внутренним `scope`. <br/>
Посмотрим еще на один пример:
```javaScript
function f1() { // родительская функция
    const all = `ВСЕМ`;
    function hi() { // дочерняя функция
        const hello = 'ПРИВЕТ';
        console.log(`${all} ${bye}`);
    }
    hi()
    function bye() { // еще дочерняя функция
        const bye = 'ПОКА';
        console.log(`${all} ${hello}`);
    }
    bye()
}

f1();
```
В коде выше будет ошибка, так как мы пытаемся получить переменные одной дочерней функции у другой дочерней функции в том же `scope`. Но обе эти функции имеют доступ к переменной их родительской функции.
Происходит это из за правил `lexical scoping`, не одна из этих функций не записана друг в друге, у них один родитель и доступ они имеют только к нему. Такие `scope` называются `sibling scopes` (Что значит брат или сестра).


## scope chain & call stack

Разберем этот код.
```javaScript
const a = 1;
f1();

function f1() {
    const b = 2;
    f2();

    function f2() {
        const c = 3;
        f3();
    }
}

function f3() {
    const d = 4;

    console.log(a + b + c + d);
    // ReferenceError
}

```
Вот как будет выглядеть стек вызовов(`call stack`) 

<div className='container-img'> <span className="img"> ![stack-vs-scope](/images/Content/Js/stack-vs-scope.png) </span></div>

Так же указано окружение переменных(`variable environment`) для кажого контекста выполнения.

### Смотрим на scope chain


