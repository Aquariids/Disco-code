---
title: 'Promise, fetch API'
id: 9
prev: '/js/advanced-js/regular-expressions'
category: 'advanced-js'
---

## Что такое promise 
`Promise` - Это объект с помощью которого мы работаем с отложенными и асинхронными операциями. Этот объект используется в качестве заполнителя для будущего результата асинхронной операциии. Или еще проще, `promise` просто контейнер для будущего значения.
С помощью промисов мы работает с `ajax`. Нам пришел ответ, от вызова `ajax`, этот ответ мы и поместим в `promise`.

### Создаем promise

Для создания промиса используем конструктор `new Promise`. Promise принимает в себя функцию с двумя аргументами.
1. `resolve` - эта функция выполнится при удачном выполнении промиса.
2. `reject` - эта функция выполнится при неудачном выполнении промиса.

```javaScript
let b = new Promise((resolve,reject)=> {})

```
Promise может находится в трех состояниях:
1. Состояние `pending:` начальное состояни. Ожидание, того когда станет доступно будущее значение.
2. Состояние `fulfilled:` операция завершена удачно.
3. Состояние `rejected:` операция завершена с ошибкой.

### then

Для управления этими состояниями существует метод `then`, мы вызываем его прямо у промиса, он доступен для всех промисов.
`then` в себя принимает колбек функцию, которая запустится когда промис перейдет в состояние выполнено(fulfilled).
```javaScript
let b = new Promise((resolve,reject)=> {
    return resolve('hi') // мы в промисе вернули resolve, а вунтри текст hi. промис выполнился
}).then(hi => console.log(hi)) // hi
// внутри then выполнилась колбек функция которая в свой аргумент приняла то, что вернул промис
```

### catch

Метод `catch` будет выполняться при неудачном выполнении кода.
```javaScript
let b = new Promise((resolve,reject)=> {
    return resolve('hi')
}).then(hi => bye).catch(()=> { // тут я вернул не hi, а bye
    alert('Привет тут ошибка') // произошла ошибка и выполнился catch
}) 
```
### finally
`finally` используется всегда в самом конце после всех `then`. Работает и при удачном выполнении и при неудачном.
Например мы можем отчистить все данные после работы промиса и работы с сервером.
```javaScript
let b = new Promise((resolve,reject)=> {
    return resolve('hi')
}).then(hi => hi).finally(()=> {
    console.log('конец'); // конец
})
```
 Далее расмотрим какие проблемы решает `promise`, а после как вообще с ним работать и для чего.

## Callback hell
Колбек ад, это когда колбеков очень много, все становится очень запутанно и непонятно.

```javaScript
// имитируем асинхронную работу
console.log('Запрос данных...'); // выводим запрос

setTimeout(()=> {
    console.log('Подготовка данных...'); // через 2 сек у нас идет подготовка

    const product = { // подготавливаем объект
        name:'TV',
        price: 3000
    }
    console.log(product); // выводим объект
    setTimeout(()=> {
        product.status = 'order'; // добавляем свойство в объект
        console.log(product.status); // order типо заказан
        setTimeout(()=> {
            product.sending = 'sent' // после типо мы отправили и бла бла бла
            console.log(product.sending); // sent
        },2000) // суть в том, что получается вот такая лесенка, это классический колбек ад
    },2000) // если нам нужна будет еще одна операция, у нас появится еще одна такая лесенка
},2000); // представим что их штук 5, вот тут и начинается ад
```

Что бы у нас наш код не превратился в колбек ад, нам понадабятся `promise`.
```javaScript
const rq = new Promise((resolve, reject) => { // создаем промис
    console.log('Запрос данных');
    setTimeout(() => {
        const product = {
            name: 'TV',
            price: 2000,
            bool: true
        };
        // получается так, что если все удачно прошло и мы получили наш объект product, то выполняется resolve, которая и принимает  в себя этот продукт
        resolve(product);
    }, 3000);
});
rq.then((product) => { // rq - это промис который выполнил свою работу, далее это переходит в then
    console.log('Подготовка данных');
    return new Promise((resolve, reject) => { // здесь мы можем вернуть еще один промис
        setTimeout(() => {
            product.status = 'order'; // модифицировать наш продукт
            if (product.bool === true) {
                resolve(product); // если у нас все четко и в bool: true, то работаем дальше
            } else { // иначе ошибка и используем reject
                reject();
                // само собой, это пример и никто не будет писать такое условие. Подробнее далее в разборе fetch
            }

        }, 2000);
    });
}).then((data) => { // тут опять получаем наш product
    data.modify = true; // меняем наш объект
    return data; // возвращаем его
}).then((data) => { 
    console.log(data);
}).catch(() => { 
    console.log('ОШИБКА');
}).finally(() => {
console.log('Конец');
});
```
По сути работа с промисами, превращается в такую вот некую цепочку промисов, при работе с `fetch` все станет намного яснее.
##  fetch API 
`fetch` - это современный способ для работы с сетевыми запросами.

### Из чего состоит fetch

### Методы для ответа fetch

### Настоящий пример callback hell
Кусочек из небольшого скажем так проекта, как это работает на практике. Перед изучением `fetch` рекомендую узнать начала про <span className = 'link_js'>[XMLHttpRequest](/js/advanced-js/ajax#не-современный-способ-ajax---xmlhttprequest)</span>.<br/>
Здесь мы будем использовать отправку данных.
```javaScript
fetch('server.php', { // тут у нас ссылка на наш сервер
        method:"POST",  // вот он метод
        headers: { // заголовок
            'Content-type':'application/json'
        },
        body: JSON.stringify(object) // объект который отправляем и сразу его парсим в json

    })
    .then(data => data.text())  // здесь мы его переводим в текст, что бы посмотреть удобно на него в консоли
    .then(data => {
        showThanksModal(message.succes);  // выводим текст об удачной отправки формы
        
        statusMessage.remove();
    }).catch(()=> {
        showThanksModal(message.failure); // уведомление об ошибки
    }).finally(()=>{
        form.reset();  // очищаем форму после отправки или после ошибки, плевать.
    });

```
### Калькулятор валюты
А тут мы повторим тот же калькулятор, что и в примере с `XMLHttpRequest`:

```javaScript
const inputRub = document.querySelector('#rub'), // получаем элементы
    inputUsd = document.querySelector('#usd');

inputRub.addEventListener('input', async () => {  // чешаем событие на инпут
  let response = await fetch('./js/current.json', { // получаем ответ в переменную response
        method: "GET", // это тоже можно не указывать
        headers: { // вообще можно написать в одну строчку без method, headers.
            'Content-type': 'application/json; charset=utf-8'
        },
    })

    // свойство ok Будет true если status в диапозоне от 200 до 299, делать проверку как у меня не обязательно
    if(response.ok && response.status === '200') { // тут хватит и просто response.ok
        let data = await response.json() // парсим наш ответ в json формат, методом json()
        inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2) // работаем с инпутами как и было до этого.
    } else {
        alert(`Ошибка запроса ${response.status}`) // Окно об ошибке
    }
})
```




Script
let a = 7; // создаем переменную

console.log(a); // 7

let b = new Promise((resolve,reject)=> { // создаем новый промис.
    // resolve - это функция которая выполнится при удачном выполнении промиса
    // reject -  при неудачном выполнении
    setTimeout(()=> { // внутрь помещаем асинхронную операцию
        resolve(a = 99); // в a присвоим 99
    },2000); // выведем через 2 сек
}).then(()=> { // нам выведет сначала 7, через 2 сек 99. И вот прикол промисов, нам не нужно опять делать setTimeout и писать опять в нем что-то
console.log(a); // для этого всего у нас есть then он принимает в себя resolve. и внутри него мы можем работать с данными и просто по цепочке создавать дальше
}).then(()=>{ // то есть по сути все что написанно внутри then, это тоже самое, что если бы мы писали это в resolve
    // мы можем убрать из resolve a = 99 и все будет работать, только в последнем then будет 8. Но если мы удалим resolve. then уже не будет работать
    console.log(a + 1); // тут уже выыведет 100 и так далее
}); // это последовательность действий, при удачной работе мы обещаем, что выплним определленную цепочку действий.
```