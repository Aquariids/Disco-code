---
title: 'Promise, fetch API'
id: 9
prev: '/js/advanced-js/regular-expressions'
category: 'advanced-js'
---

## Что такое promise 
`Promise` - Это объект с помощью которого мы работаем с отложенными и асинхронными операциями. Этот объект используется в качестве заполнителя для будущего результата асинхронной операциии. Или еще проще, `promise` просто контейнер для будущего значения.
С помощью промисов мы работает с `ajax`. Нам пришел ответ, от вызова `ajax`, этот ответ мы и поместим в `promise`.

### Смотрим на propmise без ajax
```javaScript
let a = 7; // создаем переменную

console.log(a); // 7

let b = new Promise((resolve,reject)=> { // создаем новый промис.
    // resolve - это функция которая выполнится при удачном выполнении промиса
    // reject -  при неудачном выполнении
    setTimeout(()=> { // внутрь помещаем асинхронную операцию
        resolve(a = 99); // в a присвоим 99
    },2000); // выведем через 2 сек
}).then(()=> { // нам выведет сначала 7, через 2 сек 99. И вот прикол промисов, нам не нужно опять делать setTimeout и писать опять в нем что-то
console.log(a); // для этого всего у нас есть then он принимает в себя resolve. и внутри него мы можем работать с данными и просто по цепочке создавать дальше
}).then(()=>{ // то есть по сути все что написанно внутри then, это тоже самое, что если бы мы писали это в resolve
    // мы можем убрать из resolve a = 99 и все будет работать, только в последнем then будет 8. Но если мы удалим resolve. then уже не будет работать
    console.log(a + 1); // тут уже выыведет 100 и так далее
}); // это последовательность действий, при удачной работе мы обещаем, что выплним определленную цепочку действий.
```
Небольшой пример с использованием только setTimeout:
```javaScript

console.log('Запрос данных...'); // выводим запрос

setTimeout(()=> {
    console.log('Подготовка данных...'); // через 2 сек у нас идет подготовка

    const product = { // подготавливаем объект
        name:'TV',
        price: 3000
    }
    setTimeout(()=> {
        product.status = 'order';
        console.log(product); // еще через 2 сек выводим измененный объект.
    },2000)
},2000); // Мы работаем с асинхронным кодом, но при этом колбеки позволяют соблюдать определенный порядок.
// Таким образом разрастается дерево колбеков. Если нужна будет еще одна операция, то будет еще функция и так далее.
```
Что бы у нас наше дерево не превратилось в колбек ад, нам понадабятся Promise.
```javaScript
const rq = new Promise((resolve, reject) => { // создаем промис
    console.log('Запрос данных');
    setTimeout(() => {
        const product = {
            name: 'TV',
            price: 2000,
            bool: true
        };
        // получается так, что если все удачно прошло и мы получили наш объект product, то выполняется resolve, которая и принимает  в себя этот продукт
        resolve(product);
    }, 3000);
});

rq.then((product) => { // этот продукт переходит в этот аргумент в then
    console.log('Подготовка данных');
    return new Promise((resolve, reject) => { // здесь мы можем вернуть еще один промис
        setTimeout(() => {
            product.status = 'order'; // модифицировать наш продукт
            if (product.bool === true) {
                resolve(product); // если у нас все четко и в bool: true, то работаем дальше
            } else { // иначе ошибка и используем reject
                reject();
                // само собой, это пример и никто не будет писать такое условие. Подробнее далее в разборе fetch
            }

        }, 2000);
    });
}).then((data) => { // тут опять получаем наш product
    data.modify = true; // меняем наш объект
    return data; // возвращаем его
}).then((data) => { // сейчас мы выполняем синхронный код, но он идет четко друг за другом
    console.log(data);
}).catch(() => { // catch будет выполняться если мы будем использовать reject - используется если будет ошибка какая то
    console.log('ОШИБКА');
}).finally(() => {
    // используется всегда в самом конце после всех then. Рабоатет и при reject и при resolve
    // например мы можем отчистить все данные после работы промиса и работы с сервером
});

```
##  fetch API 
`fetch` - это современный способ для работы с сетевыми запросами.

### Из чего состоит fetch

### Методы для ответа fetch
Кусочек из небольшого скажем так проекта, как это работает на практике. Перед изучением `fetch` рекомендую узнать начала про <span className = 'link_js'>[XMLHttpRequest](/js/advanced-js/ajax#не-современный-способ-ajax---xmlhttprequest)</span>.<br/>
Здесь мы будем использовать отправку данных.
```javaScript
fetch('server.php', { // тут у нас ссылка на наш сервер
        method:"POST",  // вот он метод
        headers: { // заголовок
            'Content-type':'application/json'
        },
        body: JSON.stringify(object) // объект который отправляем и сразу его парсим в json

    })
    .then(data => data.text())  // здесь мы его переводим в текст, что бы посмотреть удобно на него в консоли
    .then(data => {
        showThanksModal(message.succes);  // выводим текст об удачной отправки формы
        
        statusMessage.remove();
    }).catch(()=> {
        showThanksModal(message.failure); // уведомление об ошибки
    }).finally(()=>{
        form.reset();  // очищаем форму после отправки или после ошибки, плевать.
    });

```
### Калькулятор валюты
А тут мы повторим тот же калькулятор, что и в примере с `XMLHttpRequest`:

```javaScript
const inputRub = document.querySelector('#rub'), // получаем элементы
    inputUsd = document.querySelector('#usd');

inputRub.addEventListener('input', async () => {  // чешаем событие на инпут
  let response = await fetch('./js/current.json', { // получаем ответ в переменную response
        method: "GET", // это тоже можно не указывать
        headers: { // вообще можно написать в одну строчку без method, headers.
            'Content-type': 'application/json; charset=utf-8'
        },
    })

    // свойство ok Будет true если status в диапозоне от 200 до 299, делать проверку как у меня не обязательно
    if(response.ok && response.status === '200') { // тут хватит и просто response.ok
        let data = await response.json() // парсим наш ответ в json формат, методом json()
        inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2) // работаем с инпутами как и было до этого.
    } else {
        alert(`Ошибка запроса ${response.status}`) // Окно об ошибке
    }
})
```