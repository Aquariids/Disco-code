---
title: 'Promise API'
id: 9
prev: '/js/advanced-js/regular-expressions'
category: 'advanced-js'
---

## Что такое promise 
Promise - Это объект с помощью которого мы работаем с отложенными и асинхронными операциями. Мы говорим  если что-то выполнится, то мы обещаем что что-то выполним. 
С помощью промисов мы работаем с AJAX. 
```javaScript
let a = 7; // создаем переменную

console.log(a); // 7

let b = new Promise((resolve,reject)=> { // создаем новый промис.
    // resolve - это функция которая выполнится при удачном выполнении промиса
    // reject -  при неудачном выполнении
    setTimeout(()=> { // внутрь помещаем асинхронную операцию
        resolve(a = 99); // в a присвоим 99
    },2000); // выведем через 2 сек
}).then(()=> { // нам выведет сначала 7, через 2 сек 99. И вот прикол промисов, нам не нужно опять делать setTimeout и писать опять в нем что-то
console.log(a); // для этого всего у нас есть then он принимает в себя resolve. и внутри него мы можем работать с данными и просто по цепочке создавать дальше
}).then(()=>{ // то есть по сути все что написанно внутри then, это тоже самое, что если бы мы писали это в resolve
    // мы можем убрать из resolve a = 99 и все будет работать, только в последнем then будет 8. Но если мы удалим resolve. then уже не будет работать
    console.log(a + 1); // тут уже выыведет 100 и так далее
}); // это последовательность действий, при удачной работе мы обещаем, что выплним определленную цепочку действий.
```
Небольшой пример с использованием только setTimeout
```javaScript

console.log('Запрос данных...'); // выводим запрос

setTimeout(()=> {
    console.log('Подготовка данных...'); // через 2 сек у нас идет подготовка

    const product = { // подготавливаем объект
        name:'TV',
        price: 3000
    }
    setTimeout(()=> {
        product.status = 'order';
        console.log(product); // еще через 2 сек выводим измененный объект.
    },2000)
},2000); // Мы работаем с асинхронным кодом, но при этом колбеки позволяют соблюдать определенный порядок.
// Таким образом разрастается дерево колбеков. Если нужна будет еще одна операция, то будет еще функция и так далее.
```
Что бы у нас наше дерево не превратилось в колбек ад, нам понадабятся Promise.
```javaScript
const rq = new Promise((resolve, reject) => { // создаем промис
    console.log('Запрос данных');
    setTimeout(() => {
        const product = {
            name: 'TV',
            price: 2000,
            bool: true
        };
        // получается так, что если все удачно прошло и мы получили наш объект product, то выполняется resolve, которая и принимает  в себя этот продукт
        resolve(product);
    }, 3000);
});

rq.then((product) => { // этот продукт переходит в этот аргумент в then
    console.log('Подготовка данных');
    return new Promise((resolve, reject) => { // здесь мы можем вернуть еще один промис
        setTimeout(() => {
            product.status = 'order'; // модифицировать наш продукт
            if (product.bool === true) {
                resolve(product); // если у нас все четко и в bool: true, то работаем дальше
            } else { // иначе ошибка и используем reject
                reject();

                // само собой, это пример и никто не будет писать такое условие. Подробнее далее в разборе fetch
            }

        }, 2000);
    });
}).then((data) => { // тут опять получаем наш product
    data.modify = true; // меняем наш объект
    return data; // возвращаем его
}).then((data) => { // сейчас мы выполняем синхронный код, но он идет четко друг за другом
    console.log(data);
}).catch(() => { // catch будет выполняться если мы будем использовать reject - используется если будет ошибка какая то
    console.log('ОШИБКА ЕБЛАН');
}).finally(() => {
    // используется всегда в самом конце после всех then. Рабоатет и при reject и при resolve
    // например мы можем отчистить все данные после работы промиса и работы с сервером
});

```
 ## <a name=""> fetch API </a>>
API - это интерфейс какого-то программного обеспечения или приложения, это набор готовых решений.
Например DOM API - когда мы обращаемся к document и у него уже есть готовые методы и нам их предоставляют.
Так же можем использовать сторонние возможности. По сути это набор готовых методов и свойств которые нам дают.<br>
fetch - это и есть наш интерфейс который позволяет работать с запросами и ответами http.
XMLHttpRequest - это устаревший способ, а fetch современный
fetch построен на  promise. так мы и получаем AJAX запросы, асинхронные.
```javaScript


```

/*
Кусочек из небольшого скажем так проекта. Так это работает на практике
fetch('server.php', { тут у нас ссылка на наш сервер
        method:"POST",  вот он метод
        headers: { заголовок
            'Content-type':'application/json'
        },
        body: JSON.stringify(object) объект который отправляем и сразу его парсим в json

    })
    .then(data => data.text())  здесь мы его переводим в текст, что бы посмотреть удобно посмотреть на ннего в консоли
    .then(data => {
        console.log(data);
        showThanksModal(message.succes);  выводим текст об удачной отправки формы
        
        statusMessage.remove();
    }).catch(()=> {
        showThanksModal(message.failure); уведомление об ошибки
    }).finally(()=>{
        form.reset();  отчищаем форму после отправки или после ошибки, плевать.
    });

*/

  fetch(`https://jsonplaceholder.typicode.com/todos/${getRandomNum(1,100)}`)
  .then(response => response.json())
  .then(json => console.log(json));
function getRandomNum (max,min){
    return Math.floor(Math.random() * (max - min + 1) + min);
}  // ето я херней страдаю
