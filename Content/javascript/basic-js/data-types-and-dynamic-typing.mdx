---
title: 'Типы данных и динамическая типизация'
id: 3
prev: '/js/basic-js/variables'
next: '/js/basic-js/interpolation'
category: 'basic-js'
---


<div className = 'mdHead'>

#### Теги

<div className = 'tag_js'> [Типы данных в Javascript:](#типы-данных) </div>
<div className = 'mini_tag_js'> [number:](#числоnumber) </div>
<div className = 'mini_tag_js'> [infinity и -infinity,](#infinity-и--infinity-бесконечность) </div>
<div className = 'mini_tag_js'> [NaN.](#nannot-a-number) </div>
<div className = 'mini_tag_js'>[string](#строкаstring)</div>
<div className = 'mini_tag_js'>[boolean](#логический-типboolean)</div>
<div className = 'mini_tag_js'>[null](#null)</div>
<div className = 'mini_tag_js'>[undefined](#undefined)</div>
<div className = 'mini_tag_js'>[symbol](#символsymbol)</div>
<div className = 'mini_tag_js'>[bigInt](#bigint)</div> <br/>
<div className = 'tag_js'>[Комплексный тип данных (Object)](#комплексный-тип-данных-object)</div> <br/>
<div className = 'tag_js'>[Специальные объекты:](#специальные-объекты)</div>
<div className = 'mini_tag_js'> [массив,](#массив) </div>
<div className = 'mini_tag_js'> [функции,](#функции) </div>
<div className = 'mini_tag_js'> [объект даты,](#объект-даты) </div>
<div className = 'mini_tag_js'> [регулярные выражения и ошибки,](#регулярные-выражения-и-ошибки) </div> <br/>
<div className = 'tag_js'> [Динамическая типизация](#динамическая-типизация) </div> <br/>
<div className = 'tag_js'> [Неявное приведение типов в JavaScript:](#неявное-приведение-типов-в-javascript) </div>
<div className = 'mini_tag_js'> [string,](#string) </div>
<div className = 'mini_tag_js'> [number,](#number) </div>
<div className = 'mini_tag_js'> [boolean,](#boolean) </div>

</div>

Для проверки переменных и значений на их тип данных, в js есть метод `typeof`(<small>тут переменная или значение</small>)
```javascript
'use strict';

let num = 10;

console.log(typeof(num)) // number
console.log(typeof('строка')); // string
```
Далее я буду пользоваться этим методом для наглядной демонстрации типа данных.


## Типы данных 

В `javascript` существует восемь типов данных. Из них семь типов состоят из примитивных значений и один комплексный тип объект.
* Примитивные значения - это значения которые находятся в памяти и с которыми мы можем взаимодействовать. 

### Число(number)

Это обычные цифры, числа. Максимальное допустимое число для безопасной работы в javaScript 2<sup>53</sup> степени.
Так же кроме обычных чисел есть специальные значения: `Infinity`, `-Infinity` и `NaN` - они все относится к типу `number`.
```javascript
'use strict';

let numbers = 12;

console.log(typeof(numbers)); //number
```
#### infinity и -infinity (Бесконечность)

```javaScript
'use strict';

console.log(4 / 0); // Infinity
console.log(-4 / 0); // -Infinity

console.log(typeof(4 / 0)); // number

```
#### NaN(Not a Number) ####
`NaN` будем получать при ошибочных метематических операциях. Например умножаем то, что умножать нельзя.
```javaScript
'use strict';

console.log(4 * 's')// NaN
console.log(typeof(4 * 's'))// number

// Умножаем число на строку, получаем NaN
```
### Строка(String) ###
Строки всегда в одинарных или двойных кавычках `''` `""`.

```javascript
'use strict';

let str = 'привет'
let str2 = '12' // это строка

console.log(typeof(str)); // string
```
### Логический тип(boolean) ###

Булевый тип имеет два значения: `true`(истина) и `false`(ложь). [Используется для работы с условиями.](https://github.com/Aquariids/Js-Ts-React-etc../blob/main/JavaScript/Basic%20js/if%20and%20switch.md)
```javascript
'use strict';

let booleanTypes1 = true; 
let booleanTypes2 = false;

console.log(typeof(booleanTypes1,booleanTypes2)); // boolean
```
### null ###
`null` - это тип данных, который содержит в себе только `null`. Он подразумевает отсутствие объектного значения. 
Если проверять тип `null` то выдаст `'object'` - это особенность языка javascript.
```javascript
'use strict';

let a = null;
console.log(a); // null
```
### undefined ###
Тип `undefiend` имеет только одно значение - `undefiend`. Присваивается переменным, которые были только объявлены, без значения. Так же аргументам в функциях, для которых не были установлены значения.
```javascript
'use strict';

let a;
console.log(a); // undefined
function f1 (a,b) {
    console.log(a);
}

f1(); //undefined
```
### Символ(Symbol) ###
Тип `symbol` (символ) используется для создания уникальных идентификаторов в объектах. Если вы только изучаете javaScript, то можете пропустить этот тип данных.
```javascript
const obj = {};
const sym = Symbol();
obj[sym] = 'hi';
obj.hello = 'hello'; 
console.log(obj); // { hello: 'hello', [Symbol()]: 'hi' }
console.log(sym in obj); // true
console.log(obj[sym]); // hi
console.log(Object.keys(obj)); // ['hello']

console.log(typeof(sym)); // symbol

```
* Квадратные скобки используются для доступа к свойствам объекта, когда имя свойства неизвестно на момент написания кода или когда имя свойства содержит пробелы или другие символы, которые не допустимы в идентификаторах `Javascript`. Поэтому используем их, но пока это не очень важная информация, но написать стоило.

* Свойства созданные с помощью `Symbol` скрыты. Они не будут перечислены при использовании методов `Object.keys()`, `Object.values()` и `Object.entries()`.

### BigInt ###
`BigInt` позволяет работать с числами больше чем 2<sup>53</sup>степени.
`BigInt` создаётся путём добавления `n` в конец <b>целочисленного</b> литерала или вызова функции `BigInt()`.
```javascript
'use strict';
let a = 9007199254740991n;
let b = BigInt(9007199254740991);

let c = 1.23845722n; // error
console.log(typeof(a)); // bigint
```

## Комплексный тип данных (Object) ##                                 
  Объект - это структура данных которая может иметь в себе разные данные. При этом эти данные могут быть разного типа, это благодаря динамической типизации языка.
  ```javaScript
  'use strict';

    // этот объект содержит в себе определенные свойства(своеобразные переменные).
    // Любое свойство подразумевает пару "ключ(имя):значение(что угодно)", обязательно ставим двоеточие.
   
   const obj = {  // Создав переменную просто открываем фигурные скобки {}. Так, мы создали объект. 
     name: 'Dima',  // свойство  с ключом name со значением Dima
     age: 24, // свойство с ключом age со значением 24 и тд. 
     watchAnime: true 
     // Идут свойства через запятую, у последнего свойства ставить запятую не нужно.
  }
  // проверим на тип данных
  console.log(typeof(obj));// object
  // Что бы обратиться к свойству в объекте, пишем имя объекта и через точку свойство. Проверим тип данных свойства name
  console.log(typeof(obj.name)); // string ('Dima' - это строка)
  ```
  Комплексный он потому что на основе объекта могут быть разные конструкции(Специальные объекты)
  
  ## Специальные объекты ##
  ### Массив ###
  Массив это частный случай объекта. Он как бы в своей основе объект, но немного с другим поведением. Все данные хранятся строго по порядку!
  ```javaScript
  'use strict';
  // создав переменную прописываем квадртаные скобки []. Все, массив готов.
  const arr = ['ss', 1, {}, []]; // Массив как и объект так же может содержать в себе разные типы.
  
// Но здесь есть только значения, а Его ключи они фиксированны и идут строго по порядку от 0 - это индекс(позиция элемента)
// Например строка 'ss' - она первая и ее индекс(позиция) будет 0, далее число 1 с индексом 1 и так далее.
// В программировании все начинается с 0 (Первый элемент это всегда позиция 0).
// проверим позицию элемента (просто указываем массив и нужный индекс в квадратных скобках []).

console.log(arr[0]); // нам выдаст 'ss'

// проверим тип данных массива

console.log(typeof(arr)); // object

// проверим тип данных элемента под индексом 0

console.log(typeof(arr[0])); // string (потому что там строка 'ss')
  ```
  Пример который показывает, что массив в `javascript` - это объект.

  ```javascript
const arr = [];

arr[0] = 1;
arr['abc'] = 2;

console.log(arr['abc']); // 2
  ```
Мы как и в обычном объекте добавили `ключ:значение`. Но делать так не нужно.
  ### Функции ###

О  работе функциях я буду говорить не здесь. Пока просто проверим тип данных функции.
Мы получим `function`. Это техническая часть, углубляться пока что нет смысла. Но функция это специальный объект, просто так же имеет свой специальный тип вот и все.
```javaScript
'use strict';

const f1 function () {
return;
};

console.log(typeof(f1)) // function
```


### Объект даты ###
С объектом даты так же будем работать позже.
``` javaScript
'use strict';

let now = new Date();

console.log(typeof(now)); // object
```
### Регулярные выражения и ошибки ###
И с этими понятиями познакомимся позже
```javaScript 
'use strict';

let reg = /i/g // регулярное выражение

console.log(typeof(reg)); // object

let err = new Error(); // объект ошибки

console.log(typeof(err)); // object
```
##  Динамическая типизация  ## 
Типизация - подразумевает классификацию типов данных.<br/>
Динамическая типизация - это когда тип данных задается(классифицируется) при присваивании значения:

```javaScript
let num = 1; // JavaScript понимает, что здесь тип данных числовой, при добавлении в переменную значения.
// Это и есть Динамическая типизация, то есть она меняется в динамике.
```
Так же стоит упомянуть, что есть статическая типизация.
* Статическая типизация - это когда язык проверяет тип данных в программе во время компиляции, еще до запуска программы. 
То есть мы указываем тип во время объявления переменной

##  Неявное приведение типов в JavaScript ##
Так же динамическая типизация подразумевает неявное приведение типов. 
Неявнное приведение типов - это автоматическое приведение типа, выполняемое компилятором.
То есть когда мы это делаем неявно, не каким то специальным методом.

### String ###
Привести к строке можно с помощью конкатенации(Это склеивание строк вместе).<br/>
Конкатенация - сложение строк или строки с чем то(для этого используется математический `+`).        
```javaScript
console.log(typeof(5 + '')); // string
// Мы сложили число с пустой строкой. В итоге получили '5' - строку
console.log(typeof(undefined + '')); //string 
// Получили  'undefined' - строка
// так же можно и не с пустой строкой. Допустим добавляем через js какие то стили и нам нужно 25px
console.log(25 + 'px')); // 25px - это строка
```
Пустые массивы в операциях с конкатенацией равняются путой строке
```javaScript
 console.log(typeof([]+[])); // string
 console.log([] + 5); // даст строку '5'
 console.log(typeof({}+{})); // string
 // объект тоже превращает в строку. Но при конкатенации объект не равен пустой строке, он будет выдавать [object Object] (просто строчное представления объекта)
 console.log({} + 5); // [object Object]5
  //  Это все приведет к строке и типу данных string. Но не получится как с помощью массива превратить 5 в "5".
```  
### Number ###
К числу приводит унарный `+` это довольно частый способ.
```javaScript
    console.log(typeof(+ '5'));  // number
    let answ = +prompt('num?','');  // мы введем число(Все что мы получаем от пользователя это всегда будут строки)
    // Так вот, мы ввели число допустим 100. В prompt передалась строка '100', далее унарный + привел '100' к числу 100
```
К числу приводят операторы сравнения `>`, `<`, `<=`, `>=`.
```javaScript
    console.log(3 > '1') // вернет true.
    // js сам взял строку '1' и привел ее к числовому типу, а потом выполнил сравнение
```
Так же и арифметические операторы `-`, `*`, `/`, `%`. Кроме `+` с двумя операндами(конкатенация).
```javaScript
    console.log('3' - 2) // 1
    // js привел строку '3' в числовой тип и отнял 2. Получаем цифру 1
    // но с + произошла конкатенация
    console.log(3 + '3'); // 33 
```
### Boolean ### 
Важно запомнить значения и типы которые приводят к логическому типу.                                   
Добавим в массив все, что превращается в `false`.
```javaScript
const itIsFalse [0,'',null,undefiend,NaN]; // все это приведет в условии к false
// если мы получаем false, то условие не будет выполнено, если true - будет.
if(0 == '') {
console.log('0')
} // это условие сработает, так как 0 - false и '' тоже false. false равно false? да, получим true. Об условиях тоже позже. 
let switcher = null;
  if (switcher) { // не сработает, так как в переменной null.
    console.log('working...');
  }
// так же довольно часто используется подобный синтаксис:
if(argument) { // мы передаем некий аргумент(если внутри функции например)или переменную. Если она пуста, код не выполнится, так как там будет undefiend.
console.log('я что-то cделаю если в переменной, что-то будет')
}
```
Все остальное будет `true`. Любая цифра или число кроме `0`, любая строка кроме пустой `''`. 
Так же любой объект в логическом контексте – `true`, даже если это пустой массив `[]` или объект `{}` 
  ```javaScript
  if ({} && []) {
   console.log("Все объекты - true!"); // код сработает.
  } 
  ```
 Логические операторы`!`,`!!`, `&&`, `||`
 ```javaScript
  console.log(typeof(!!'42432')); // boolean
  console.log(2 || '')  // 2
  // оператор или || и оператор && вернут числа. Но для этого они неявно преобразует их в логический тип. 
  console.log('he' && 12) // 12
```
Когда мы будем говорить про операторы, то все станет более менее ясно.
